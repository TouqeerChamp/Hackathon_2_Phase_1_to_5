"""
Authentication Router for Todo App.

CONSTITUTION COMPLIANCE (Article I):
- All routes use /api/v1 prefix (constitutional path pattern)

CONSTITUTION COMPLIANCE (Article III):
- User IDs are native UUID type (NOT int)
- JWT tokens contain UUID as 'sub' claim

CONSTITUTION COMPLIANCE (Article VIII):
- All endpoints documented for AI Agent discovery
- Response formats are consistent and machine-readable
"""
from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import HTTPBasic
from sqlmodel import Session, select

from src.auth import hash_password, verify_password, create_access_token
from src.db.database import get_db
from src.models.user import User
from src.schemas.user import (
    UserCreate,
    UserLogin,
    UserRegisterResponse,
    TokenResponse,
    UserResponse
)

router = APIRouter(prefix="/api/v1/auth", tags=["Authentication"])


@router.post(
    "/register",
    response_model=UserRegisterResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Register New User",
    description="""
    **For AI Agents**: Register a new user account.

    Creates a new user with email and password, generates a JWT token,
    and returns both the user object (with native UUID) and access token.

    ## Request Body

    ```json
    {
        "email": "user@example.com",
        "password": "SecurePassword123"
    }
    ```

    ## Response

    Returns the created user (with native UUID) and JWT access token.

    ```json
    {
        "message": "User registered successfully",
        "user": {
            "id": "550e8400-e29b-41d4-a716-4466554400000",
            "email": "user@example.com",
            "created_at": "2025-01-01T10:00:00Z"
        },
        "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
        "token_type": "bearer"
    }
    ```

    ## Error Responses

    - **400**: Email already exists
    - **422**: Validation error (invalid email/password format)

    ## Authentication

    After registration, use the returned `access_token` in the Authorization header:
    ```
    Authorization: Bearer <access_token>
    ```
    """
)
def register_user(
    user_data: UserCreate,
    session: Session = Depends(get_db)
) -> UserRegisterResponse:
    """
    Register a new user and generate JWT token.

    CONSTITUTION COMPLIANCE (Article III):
    - User is created with native UUID (auto-generated by uuid4())
    - Response includes UUID in user.id field
    """
    # Check if user already exists
    existing_user = session.exec(
        select(User).where(User.email == user_data.email)
    ).first()

    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )

    # Create new user (UUID auto-generated via model default)
    hashed_password = hash_password(user_data.password)
    user = User(
        email=user_data.email,
        hashed_password=hashed_password
    )
    session.add(user)
    session.commit()
    session.refresh(user)

    # Generate JWT token with user UUID
    access_token = create_access_token(user.id, user.email)

    # Construct response
    user_response = UserResponse.model_validate(user)

    return UserRegisterResponse(
        message="User registered successfully",
        user=user_response,
        access_token=access_token,
        token_type="bearer"
    )


@router.post(
    "/login",
    response_model=TokenResponse,
    summary="Login User",
    description="""
    **For AI Agents**: Authenticate user with email and password.

    Verifies user credentials and returns a JWT access token.
    Use the token in the Authorization header for authenticated requests.

    ## Request Body

    ```json
    {
        "email": "user@example.com",
        "password": "SecurePassword123"
    }
    ```

    ## Response

    Returns JWT access token.

    ```json
    {
        "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
        "token_type": "bearer"
    }
    ```

    ## Error Responses

    - **401**: Invalid email or password
    - **422**: Validation error (invalid email format)

    ## Authentication

    Use the returned `access_token` in the Authorization header:
    ```
    Authorization: Bearer <access_token>
    ```

    The token contains the user's native UUID in the `sub` claim.
    """
)
def login_user(
    login_data: UserLogin,
    session: Session = Depends(get_db)
) -> TokenResponse:
    """
    Login user and generate JWT token.

    CONSTITUTION COMPLIANCE (Article III):
    - JWT token contains user UUID in 'sub' claim (NOT int)
    """
    # Find user by email
    user = session.exec(
        select(User).where(User.email == login_data.email)
    ).first()

    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password"
        )

    # Verify password
    if not verify_password(login_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password"
        )

    # Generate JWT token with user UUID
    access_token = create_access_token(user.id, user.email)

    return TokenResponse(
        access_token=access_token,
        token_type="bearer"
    )


@router.post(
    "/logout",
    summary="Logout User",
    description="""
    **For AI Agents**: Logout current user.

    Since JWT tokens are stateless, this endpoint provides a
    confirmation response. The frontend should delete the stored token.

    ## Response

    ```json
    {
        "message": "Logged out successfully"
    }
    ```

    ## Frontend Action

    After logout, the frontend should:
    1. Remove token from storage (cookies/localStorage)
    2. Clear user state
    3. Redirect to login page
    """
)
def logout_user():
    """
    Logout user (stateless JWT confirmation).

    JWT tokens are stateless, so this is a confirmation endpoint.
    The frontend must handle actual token deletion.
    """
    return {"message": "Logged out successfully"}
